<!doctype html>
<html lang="en" style="height: 100%;">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="icon" href="https://kovu.dog/favicon.webp" sizes="any" type="image/webp" />
  <title>üçå</title>
  <style>
    body {
      background-color: #000;
      margin: 0;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      position: relative;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
    }

    #sticker {
      height: 50%;
      cursor: pointer;
      user-select: none;
      -webkit-user-drag: none;
      -webkit-tap-highlight-color: transparent;
      z-index: 10;
      position: relative;
      transition: transform 0.2s ease-out;
      will-change: transform;
      touch-action: none;
    }

    #sticker:hover {
      transform: scale(1.1);
    }

    .banana {
      position: absolute;
      top: -100px;
      z-index: 1;
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
      animation-name: fall;
      animation-timing-function: linear;
      animation-fill-mode: forwards;
      transition: opacity 0.25s ease-out;
      opacity: 1;
    }

    .banana.fading {
      opacity: 0 !important;
    }

    @keyframes fall {
      to {
        transform: translateY(120vh);
      }
    }

    #char-btn {
      position: absolute;
      bottom: 30px;
      z-index: 20;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 32px;
      min-height: 56px;
      font-size: 16px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1.25px;
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      transition: transform 0.1s, background-color 0.2s;
      outline: none;
      touch-action: manipulation;
      white-space: nowrap;
    }

    @media (max-width: 600px) {
      #char-btn {
        width: auto;
        max-width: 90%;
        white-space: normal;
        height: auto;
        font-size: clamp(13px, 5vw, 18px);
        line-height: 1.2;
        padding: 16px 24px;
        bottom: 50px;
      }
    }

    #char-btn:hover {
      transform: scale(1.1);
    }

    #char-btn:active {
      background-color: #0D47A1;
      transform: scale(0.9);
    }

    #char-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 100;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      touch-action: manipulation;
    }

    #char-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .char-option {
      width: 25%;
      max-width: 200px;
      cursor: pointer;
      transition: transform 0.2s;
      border-radius: 10px;
      padding: 10px;
    }

    .char-option img {
      width: 100%;
      height: auto;
      display: block;
      pointer-events: none;
    }

    .char-option:hover {
      transform: scale(1.1);
    }

    .char-option:active {
      transform: scale(0.9);
    }

  </style>
</head>
<body oncontextmenu="return false;">
  <img id="sticker" src="sticker.webp" draggable="false" onpointerdown="handleClick(event)">
  <button id="char-btn" onclick="openMenu()">Choose your character!</button>
  <div id="char-overlay" onclick="closeMenu(event)">
    <div class="char-option" onclick="selectChar('kovu.webp')">
      <img src="kovu.webp" draggable="false">
    </div>
    <div class="char-option" onclick="selectChar('maymoo.webp')">
      <img src="maymoo.webp" draggable="false">
    </div>
    <div class="char-option" onclick="selectChar('nyx.webp')">
      <img src="nyx.webp" draggable="false">
    </div>
  </div>
  <script>
    const bananaSrc = 'banana.svg';
    const audioFiles = {
      main: 'audio.flac',
      voice: 'voice.flac',
      choose: 'choose.flac',
      cheer: 'cheer.flac',
      start: 'start.flac'
    };
    const silenceTrim = 1000;
    const baseRotationSpeed = 0.6;
    const fadeDuration = 250;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const buffers = {};
    let mainAudioDuration = 0;
    async function loadAudio(key, url) {
      try {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const decodedBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        buffers[key] = decodedBuffer;
        if (key === 'main') mainAudioDuration = decodedBuffer.duration;
      } catch (e) {
        console.error("Failed to load audio:", url, e);
      }
    }
    Object.keys(audioFiles).forEach(key => loadAudio(key, audioFiles[key]));
    let activeSources = [];
    let voiceSource = null;
    let chooseSource = null;
    function playSound(key, volume = 1.0, loop = false) {
      if (!buffers[key]) return null;
      const source = audioCtx.createBufferSource();
      source.buffer = buffers[key];
      source.loop = loop;
      const gainNode = audioCtx.createGain();
      gainNode.gain.value = volume;
      source.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      source.start(0);
      return { source, gainNode };
    }
    function unlockAudioContext() {
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }
    function openMenu() {
      unlockAudioContext();
      stopMenuAudio();
      const v = playSound('voice', 1.0);
      if (v) voiceSource = v.source;
      const c = playSound('choose', 1.0, true);
      if (c) chooseSource = c.source;
      document.getElementById('char-overlay').classList.add('visible');
    }
    function stopMenuAudio() {
      if (voiceSource) {
        try { voiceSource.stop(); } catch (e) { }
        voiceSource = null;
      }
      if (chooseSource) {
        try { chooseSource.stop(); } catch (e) { }
        chooseSource = null;
      }
    }
    function closeMenu(e) {
      if (e.target.id === 'char-overlay') {
        document.getElementById('char-overlay').classList.remove('visible');
        stopMenuAudio();
        playSound('cheer', 1.0);
        playSound('start', 1.0);
      }
    }
    function selectChar(filename) {
      stopMenuAudio();
      playSound('cheer', 1.0);
      playSound('start', 1.0);
      sticker.src = filename;
      document.getElementById('char-overlay').classList.remove('visible');
    }
    let currentRotation = 0;
    let startRotation = 0;
    let targetRotation = 0;
    let startTime = 0;
    let endTime = 0;
    let fadeStartTime = 0;
    let isAnimating = false;
    let rainGenInterval = null;
    let fadeTimer = null;
    let stopTimer = null;
    let spawnRate = 100;
    const sticker = document.getElementById('sticker');
    function animate() {
      if (!isAnimating) return;
      const now = Date.now();
      if (now >= endTime) {
        isAnimating = false;
        sticker.style.transition = 'none';
        sticker.style.transform = '';
        void sticker.offsetWidth;
        sticker.style.transition = 'transform 0.2s ease-out';
        return;
      }
      const progress = (now - startTime) / (endTime - startTime);
      currentRotation = startRotation + ((targetRotation - startRotation) * progress);
      updateTransform(currentRotation);
      requestAnimationFrame(animate);
    }
    function updateTransform(deg) {
      const normalizedAngle = (deg % 360);
      const radians = normalizedAngle * (Math.PI / 360);
      const pulseFactor = Math.sin(radians);
      const scale = 1.1 + (0.3 * pulseFactor);
      sticker.style.transform = `scale(${scale}) rotate(${deg}deg)`;
    }
    function handleClick(e) {
      if (e) e.preventDefault();
      unlockAudioContext();
      const now = Date.now();
      const rawDurationMs = (mainAudioDuration || 1) * 1000;
      const effectiveDurationMs = Math.max(0, rawDurationMs - silenceTrim);
      const instance = playSound('main', 1.0);
      if (instance) {
        activeSources.unshift(instance);
        activeSources.forEach((item, index) => {
          const time = audioCtx.currentTime;
          if (index === 0) item.gainNode.gain.setTargetAtTime(1.0, time, 0.01);
          else if (index === 1) item.gainNode.gain.setTargetAtTime(0.75, time, 0.01);
          else if (index === 2) item.gainNode.gain.setTargetAtTime(0.50, time, 0.01);
          else item.gainNode.gain.setTargetAtTime(0.25, time, 0.01);
        });
        instance.source.onended = function () {
          activeSources = activeSources.filter(item => item !== instance);
        };
      }
      if (!isAnimating) currentRotation = 0;
      startRotation = currentRotation;
      startTime = now;
      endTime = now + effectiveDurationMs;
      fadeStartTime = endTime - fadeDuration;
      const duration = endTime - startTime;
      const projectedRotation = startRotation + (duration * baseRotationSpeed);
      targetRotation = Math.round(projectedRotation / 360) * 360;
      if (!isAnimating) {
        isAnimating = true;
        sticker.style.transition = 'none';
        requestAnimationFrame(animate);
      }
      clearTimeout(fadeTimer);
      clearTimeout(stopTimer);
      spawnRate = Math.max(10, spawnRate - 15);
      startRainGeneration();
      resetBananasVisibility();
      const timeUntilFade = Math.max(0, effectiveDurationMs - fadeDuration);
      fadeTimer = setTimeout(() => fadeExistingBananas(), timeUntilFade);
      stopTimer = setTimeout(() => {
        stopRainGeneration();
        removeBananas();
      }, effectiveDurationMs);
    }
    function startRainGeneration() {
      if (rainGenInterval) clearInterval(rainGenInterval);
      rainGenInterval = setInterval(createBanana, spawnRate);
    }
    function stopRainGeneration() {
      clearInterval(rainGenInterval);
      rainGenInterval = null;
      spawnRate = 100;
    }
    function removeBananas() {
      document.querySelectorAll('.banana').forEach(b => b.remove());
    }
    function resetBananasVisibility() {
      document.querySelectorAll('.banana').forEach(b => {
        b.classList.remove('fading');
        b.style.opacity = '';
        b.style.transitionDuration = '';
      });
    }
    function fadeExistingBananas() {
      document.querySelectorAll('.banana').forEach(b => {
        b.classList.add('fading');
      });
    }
    function createBanana() {
      const b = document.createElement('img');
      b.src = bananaSrc;
      b.className = 'banana';
      b.draggable = false;
      b.style.left = Math.random() * 100 + 'vw';
      b.style.width = (30 + Math.random() * 50) + 'px';
      const duration = 2 + Math.random() * 3;
      b.style.animationDuration = duration + 's';
      b.addEventListener('animationend', () => {
        if (b.parentNode) b.remove();
      });
      const now = Date.now();
      if (now > fadeStartTime) {
        const timeRemaining = endTime - now;
        let startOpacity = Math.max(0, Math.min(1, timeRemaining / fadeDuration));
        b.style.opacity = startOpacity;
        b.style.transitionDuration = (timeRemaining / 1000) + 's';
        requestAnimationFrame(() => {
          b.classList.add('fading');
          b.style.opacity = '';
        });
      }
      document.body.appendChild(b);
    }
  </script>
</body>
</html>
